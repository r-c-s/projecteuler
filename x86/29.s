#------------------------------------------------------------------------------
# PROJECT EULER
# PROBLEM 29
#------------------------------------------------------------------------------
# Consider all integer combinations of ab for 2 <= a <= 5 and 2 <= b <= 5:
#
# 2^2=4, 2^3=8, 2^4=16, 2^5=32
# 3^2=9, 3^3=27, 3^4=81, 3^5=243
# 4^2=16, 4^3=64, 4^4=256, 4^5=1024
# 5^2=25, 5^3=125, 5^4=625, 5^5=3125
# If they are then placed in numerical order, with any repeats removed, 
# we get the following sequence of 15 distinct terms:
#
# 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
#
# How many distinct terms are in the sequence generated by a^b for 
# 2 <= a <= 100 and 2 <= b <= 100?
#------------------------------------------------------------------------------
# SOLUTION: 9183
#------------------------------------------------------------------------------
# as -32 29.s -o 29.o
# gcc -m32 29.o -o 29
#------------------------------------------------------------------------------

dec32_format:
	.string "%d\n"

.section .text
.globl main

main:
	call	find_num
	pushl	%eax
	call	print32

#------------------------------------------------------------------------------
main_exit:
	xor		%eax, %eax
	incl	%eax
	xor		%ebx, %ebx
	int		$0x80

#------------------------------------------------------------------------------
.type print32, @ function

print32:
	pushl	4(%esp)
	pushl	$dec32_format
	call	printf
	addl	$8, %esp
	ret


#------------------------------------------------------------------------------
.type find_num, @ function

find_num:
	movl	%esp, %ecx
	xor		%edx, %edx
	xor		%edi, %edi
	incl	%edi
	
fn_loop:
	cmpl	$5, %edi
	je		fn_exit
	incl	%edi
	xor		%ebx, %ebx
	incl	%ebx

fn_inner_loop:
	cmpl	$5, %ebx
	je		fn_loop
	incl	%ebx
	pushl	%edx
	pushl	%ecx
	pushl	%edi
	pushl	%ebx
	call	power
	popl	%ebx
	popl	%edi
	popl	%ecx
	popl	%edx
	pushl	%edx
	pushl	%edi
	pushl	%ebx
	pushl	%eax
	pushl	%ecx
	call	already_in
	cmpl	$1, %eax
	popl	%ecx
	popl	%eax
	popl	%ebx
	popl	%edi
	popl	%edx
	je		fn_inner_loop
	pushl	%eax
	incl	%edx
	jmp		fn_inner_loop

fn_exit:
	movl	%edx, %eax
	movl	%ecx, %esp
	ret


#------------------------------------------------------------------------------
.type already_in, @ function

already_in:
	xor		%eax, %eax
	movl	8(%esp), %ebx
	movl	4(%esp), %ecx
	movl	%esp, %edx
	addl	$8, %edx

ai_loop:
	addl	$-4, %ecx
	cmpl	%ecx, %edx
	je		ai_exit
	cmpl	(%ecx), %ebx
	jne		ai_loop
	addl	$1, %eax

ai_exit:
	ret

#------------------------------------------------------------------------------
.type power, @ function

power:
	movl	8(%esp), %ecx
	movl	%ecx, %eax
	movl	4(%esp), %edi

p_loop:
	decl	%edi
	cmpl	$0, %edi
	je		p_exit
	mul		%ecx
	jmp		p_loop

p_exit:
	ret
















